/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/cats.js":
/*!*********************!*\
  !*** ./src/cats.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usefullFunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usefullFunc */ \"./src/usefullFunc.js\");\n\r\n\r\nconst MAX_CATS = 78;\r\n\r\n// Create an array of integers\r\nlet imageNumbers = Array(MAX_CATS)\r\n  .fill()\r\n  .map((v, i) => i + 1);\r\n\r\nimageNumbers = (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.shuffle)(imageNumbers);\r\n\r\nlet currentImageIndex = 0;\r\n\r\n// When the button is clicked, change the image source to the current index\r\nfunction loadCat() {\r\n  let catImg = document.getElementById(\"catImage\");\r\n  let imageCache = document.getElementById(\"imageCache\");\r\n\r\n  catImg.src = \"standingCats/\" + imageNumbers[currentImageIndex] + \".jpg\";\r\n\r\n  // When on last cat, set index to 0 and reshuffle\r\n  if (currentImageIndex >= MAX_CATS - 1) {\r\n    currentImageIndex = 0;\r\n    imageNumbers = (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.shuffle)(imageNumbers);\r\n  } else {\r\n    // Cache the next image\r\n    imageCache.src =\r\n      \"standingCats/\" + imageNumbers[currentImageIndex + 1] + \".jpg\";\r\n    currentImageIndex++;\r\n  }\r\n}\r\n\r\nloadCat();\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/cats.js?");

/***/ }),

/***/ "./src/chess.js":
/*!**********************!*\
  !*** ./src/chess.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usefullFunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usefullFunc */ \"./src/usefullFunc.js\");\n\r\n\r\nlet chessToggleState = 0;\r\nlet chessData = {};\r\nlet chessChart;\r\n\r\nfunction switchChessDots() {\r\n  let circles = Array.from(document.getElementsByClassName(\"chessCircles\"));\r\n  let desc = document.getElementById(\"chessDesc\");\r\n\r\n  switch (chessToggleState) {\r\n    case 0:\r\n      desc.innerHTML = \"How has my chess rating improved over time?\";\r\n      break;\r\n    case 1:\r\n      desc.innerHTML = \"This graph shows my win % at each hour of the day.\";\r\n      break;\r\n  }\r\n  circles.forEach((c) =>\r\n    c.id.slice(-1) == chessToggleState\r\n      ? (c.style.fill = \"black\")\r\n      : (c.style.fill = \"none\")\r\n  );\r\n}\r\n\r\nfunction chessToggle() {\r\n  switchChessDots();\r\n  switch (chessToggleState) {\r\n    case 0:\r\n      updateChessNormal();\r\n      break;\r\n\r\n    case 1:\r\n      updateChessPerHour();\r\n      break;\r\n  }\r\n  chessToggleState == 1 ? (chessToggleState = 0) : chessToggleState++;\r\n}\r\n\r\nfunction fetchChess() {\r\n  const primaryUrl = \"https://api.artomweb.com/cache/chess\";\r\n  const fallbackUrl =\r\n    \"https://docs.google.com/spreadsheets/d/e/2PACX-1vQqA27pG_xkV7W0Gu4KfYcV3fjkIj0WNz7-DlGDMNtXtNkR4ECA85-BWEgBbz7vYh7aqijPtLpFhw8h/pub?output=csv\";\r\n\r\n  function parseCSV(url) {\r\n    Papa.parse(url, {\r\n      download: true,\r\n      header: true,\r\n      complete: function (results) {\r\n        try {\r\n          processChess(results.data);\r\n        } catch (error) {\r\n          console.log(\"Error processing chess data:\", error);\r\n          if (url !== fallbackUrl) {\r\n            console.log(\"Trying the fallback URL...\");\r\n            parseCSV(fallbackUrl);\r\n          } else {\r\n            let chessCard = document.getElementById(\"chessCard\");\r\n            chessCard.style.display = \"none\";\r\n          }\r\n        }\r\n      },\r\n      error: function (error) {\r\n        console.log(\"Failed to fetch chess data from:\", url);\r\n        if (url === primaryUrl) {\r\n          console.log(\"Trying the fallback URL...\");\r\n          parseCSV(fallbackUrl);\r\n        } else {\r\n          let chessCard = document.getElementById(\"chessCard\");\r\n          chessCard.style.display = \"none\";\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  // Try to fetch data from the primary URL first\r\n  parseCSV(primaryUrl);\r\n}\r\n\r\nfetchChess();\r\n\r\nfunction processChess(data) {\r\n  updateChessData(data);\r\n\r\n  plotChess();\r\n  chessToggle();\r\n}\r\n\r\nfunction updateChessNormal() {\r\n  const { labels, graphData } = chessData;\r\n\r\n  chessChart.options.scales = {\r\n    x: {\r\n      ticks: {\r\n        maxTicksLimit: 4,\r\n      },\r\n    },\r\n\r\n    y: {\r\n      title: {\r\n        text: \"Chess rating\",\r\n        display: true,\r\n      },\r\n      beginAtZero: true,\r\n    },\r\n  };\r\n\r\n  chessChart.options.plugins.tooltip.callbacks = {};\r\n\r\n  chessChart.data.labels = labels;\r\n  chessChart.data.datasets = [\r\n    {\r\n      data: graphData,\r\n      backgroundColor: \"#81b29a\",\r\n      tension: 0.1,\r\n      fill: true,\r\n    },\r\n  ];\r\n\r\n  chessChart.update();\r\n}\r\n\r\nfunction updateChessPerHour() {\r\n  const { labelsByHour, dataByHour, pointRadiusArray } = chessData;\r\n\r\n  chessChart.options.scales.y = {\r\n    title: {\r\n      text: \"Win %\",\r\n      display: true,\r\n    },\r\n    beginAtZero: true,\r\n  };\r\n\r\n  chessChart.options.plugins.tooltip.callbacks = {\r\n    label: function (context) {\r\n      let label = context.dataset.label || \"\";\r\n\r\n      if (label) {\r\n        label += \": \";\r\n      }\r\n\r\n      if (context.parsed.y !== null) {\r\n        label += context.parsed.y + \"%\";\r\n      }\r\n      return label;\r\n    },\r\n    title: function (tooltipItem) {\r\n      return tooltipItem[0].label + \":00\";\r\n    },\r\n  };\r\n\r\n  chessChart.options.scales.x = {\r\n    type: \"linear\",\r\n    position: \"bottom\",\r\n    ticks: {\r\n      stepSize: 1,\r\n      callback: function (value, index, values) {\r\n        return `${value}:00`;\r\n      },\r\n    },\r\n  };\r\n\r\n  chessChart.data.labels = labelsByHour;\r\n  chessChart.data.datasets = [\r\n    {\r\n      data: dataByHour,\r\n      backgroundColor: \"#81b29a\",\r\n      tension: 0.1,\r\n      fill: true,\r\n      pointRadius: pointRadiusArray,\r\n    },\r\n  ];\r\n\r\n  chessChart.update();\r\n}\r\n\r\nfunction updateChessData(data) {\r\n  data.forEach((elt) => {\r\n    elt.startTime = +elt.startTime * 1000;\r\n    elt.Date = moment(+elt.startTime).format(\"DD/MM/YYYY\");\r\n    elt.gameLength = +elt.gameLength;\r\n  });\r\n\r\n  data = _.sortBy(data, \"startTime\");\r\n\r\n  const dataByDay = _.chain(data)\r\n    .groupBy((d) => d.Date)\r\n    .map((entries, day) => {\r\n      let highest = _.maxBy(entries, (entry) => +entry.myRating);\r\n      return {\r\n        startTime: highest.startTime,\r\n        day,\r\n        highest: +highest.myRating,\r\n      };\r\n    })\r\n    .sortBy(\"startTime\")\r\n    .value();\r\n\r\n  const hoursOfDay = Array.from({ length: 24 }, (_, i) =>\r\n    i.toString().padStart(2, \"0\")\r\n  );\r\n\r\n  const byHour = _.chain(data)\r\n    .groupBy((d) => moment(+d.startTime).format(\"HH\"))\r\n    .map((entries, hour) => {\r\n      return {\r\n        hour: +hour,\r\n        winPercent:\r\n          Math.round(\r\n            (entries.filter((e) => e.myResult == \"win\").length /\r\n              entries.length) *\r\n              100 *\r\n              10\r\n          ) / 10,\r\n      };\r\n    })\r\n    .sortBy(\"startTime\")\r\n    .value();\r\n\r\n  const completedByTimeOfDay = _.map(hoursOfDay, (hour) => {\r\n    const existingHourData = byHour.find(\r\n      (item) => item.hour === parseInt(hour)\r\n    );\r\n    return existingHourData || { hour: +hour, winPercent: 0 };\r\n  });\r\n\r\n  // console.log(completedByTimeOfDay);\r\n\r\n  const labelsByHour = completedByTimeOfDay.map((item) => item.hour);\r\n  const dataByHour = completedByTimeOfDay.map((item) => item.winPercent);\r\n\r\n  const pointRadiusArray = completedByTimeOfDay.map((item) =>\r\n    item.winPercent !== 0 ? 3 : 0\r\n  );\r\n\r\n  const dateOfLastGame = data[data.length - 1].startTime;\r\n\r\n  const timeSinceLastTest = (new Date().getTime() - dateOfLastGame) / 1000;\r\n\r\n  const dateOfLastTestMessage =\r\n    moment(dateOfLastGame).format(\"Do [of] MMMM\") +\r\n    \" (\" +\r\n    (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.createTimeMessage)(timeSinceLastTest) +\r\n    \" ago)\";\r\n\r\n  document.getElementById(\"timeSinceLastChess\").innerHTML =\r\n    dateOfLastTestMessage;\r\n\r\n  const highestRating = _.maxBy(data, \"myRating\").myRating;\r\n\r\n  const numGames = data.length;\r\n\r\n  let ratings = data.map((game) => +game.myRating);\r\n\r\n  const trend = (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.findLineByLeastSquares)(ratings);\r\n\r\n  const ratingChange = trend[1][1] - trend[0][1];\r\n\r\n  const delta = _.sumBy(data, \"gameLength\");\r\n\r\n  console.log(delta);\r\n  console.log(numGames);\r\n\r\n  const changeInScorePerHourSigned = (ratingChange * (3600 / delta)).toFixed(2);\r\n\r\n  const PorNchange = changeInScorePerHourSigned > 0 ? \"+\" : \"-\";\r\n\r\n  const changeInScorePerHour = Math.abs(changeInScorePerHourSigned);\r\n\r\n  const timeMessage = Math.round(delta / (60 * 60)) + \" hours\";\r\n\r\n  document.getElementById(\"ChessHighestRating\").innerHTML = highestRating;\r\n  document.getElementById(\"ChessTimePlaying\").innerHTML = timeMessage;\r\n  document.getElementById(\"ChessNumGames\").innerHTML = numGames;\r\n  document.getElementById(\"ChessChangePerHour\").innerHTML =\r\n    PorNchange + changeInScorePerHour;\r\n\r\n  let labels = dataByDay.map((elt) => elt.day);\r\n  let graphData = dataByDay.map((elt) => +elt.highest);\r\n\r\n  // plotChess(graphData, labels);\r\n\r\n  chessData = {\r\n    labels,\r\n    graphData,\r\n    labelsByHour,\r\n    dataByHour,\r\n    pointRadiusArray,\r\n  };\r\n}\r\n\r\nfunction plotChess(data, labels) {\r\n  let ctx = document.getElementById(\"ChessChart\").getContext(\"2d\");\r\n\r\n  // console.log(data, labels);\r\n\r\n  chessChart = new Chart(ctx, {\r\n    type: \"line\",\r\n    data: {\r\n      // labels: labels,\r\n      // datasets: [\r\n      //   {\r\n      //     tension: 0.3,\r\n      //     // borderColor: \"black\",\r\n      //     data,\r\n      //     backgroundColor: \"#81b29a\",\r\n      //     fill: true,\r\n      //     // fill: false,\r\n      //   },\r\n      // ],\r\n    },\r\n    options: {\r\n      maintainAspectRatio: true,\r\n      responsive: true,\r\n\r\n      plugins: {\r\n        legend: {\r\n          display: false,\r\n        },\r\n      },\r\n      scales: {\r\n        x: {\r\n          ticks: {\r\n            maxTicksLimit: 4,\r\n          },\r\n        },\r\n\r\n        y: {\r\n          title: {\r\n            text: \"Chess rating\",\r\n            display: true,\r\n          },\r\n          beginAtZero: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/chess.js?");

/***/ }),

/***/ "./src/cod.js":
/*!********************!*\
  !*** ./src/cod.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usefullFunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usefullFunc */ \"./src/usefullFunc.js\");\n// https://docs.google.com/spreadsheets/d/e/2PACX-1vR1niW_6GahrZO8AwptrW72A3EAbgLhROhApyzhwfq5_m_OTAfQq0MBD6OCsRfL0vHFYs2FKYluYCHd/pub?output=csv\r\n\r\n\r\nlet codData = {};\r\nlet codChart;\r\nlet codToggleState = 0;\r\n\r\nfunction switchCodDots() {\r\n  let circles = Array.from(document.getElementsByClassName(\"codCircles\"));\r\n  let desc = document.getElementById(\"cod-desc\");\r\n\r\n  switch (codToggleState) {\r\n    case 0:\r\n      desc.innerHTML =\r\n        \"Ben and I sometimes play Call of Duty together, who's winning? This graph shows the margin that either of us was winning by overall.\";\r\n      break;\r\n    case 1:\r\n      desc.innerHTML = \"This graph shows the number of games won per day\";\r\n      break;\r\n  }\r\n  circles.forEach((c) =>\r\n    c.id.slice(-1) == codToggleState\r\n      ? (c.style.fill = \"black\")\r\n      : (c.style.fill = \"none\")\r\n  );\r\n}\r\n\r\nfunction codToggle() {\r\n  switchCodDots();\r\n  switch (codToggleState) {\r\n    case 0:\r\n      updateCodRunning();\r\n      break;\r\n\r\n    case 1:\r\n      updateCodNormal();\r\n      break;\r\n  }\r\n  codToggleState == 1 ? (codToggleState = 0) : codToggleState++;\r\n}\r\n\r\nfunction fetchCod() {\r\n  const primaryUrl = \"https://api.artomweb.com/cache/cod\";\r\n  const fallbackUrl =\r\n    \"https://docs.google.com/spreadsheets/d/e/2PACX-1vSkxuvS6JNMaDdFtWzxpH4GN2g7DDOVjM0fkjv9QviwwTFBYP_Y6F2g9Thdf2Zer3DNzTQnNraaJt5a/pub?output=csv\";\r\n\r\n  function parseCSV(url) {\r\n    Papa.parse(url, {\r\n      download: true,\r\n      header: true,\r\n      complete: function (results) {\r\n        try {\r\n          processCod(results.data);\r\n        } catch (error) {\r\n          console.log(\"Error processing cod data:\", error);\r\n          if (url !== fallbackUrl) {\r\n            console.log(\"Trying the fallback URL...\");\r\n            parseCSV(fallbackUrl);\r\n          } else {\r\n            let CODCard = document.getElementById(\"CODCard\");\r\n            CODCard.style.display = \"none\";\r\n          }\r\n        }\r\n      },\r\n      error: function (error) {\r\n        console.log(\"Failed to fetch cod data from:\", url);\r\n        if (url === primaryUrl) {\r\n          console.log(\"Trying the fallback URL...\");\r\n          parseCSV(fallbackUrl);\r\n        } else {\r\n          let CODCard = document.getElementById(\"CODCard\");\r\n          CODCard.style.display = \"none\";\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  // Try to fetch data from the primary URL first\r\n  parseCSV(primaryUrl);\r\n}\r\n\r\nfetchCod();\r\n\r\nfunction processCod(dataIn) {\r\n  updateCodData(dataIn);\r\n\r\n  drawCodChart();\r\n  codToggle();\r\n}\r\n\r\nfunction updateCodData(data) {\r\n  // console.log(data);\r\n  data.forEach((day) => {\r\n    day.Archie = +day.Archie;\r\n    day.Ben = +day.Ben;\r\n  });\r\n\r\n  const dataArchie = data.map((e) => e.Archie);\r\n  const dataBen = data.map((e) => -e.Ben);\r\n\r\n  const labels = data.map((e) => e.Date);\r\n\r\n  codData.normalView = { dataArchie, dataBen, labels };\r\n\r\n  data.forEach((day, idx) => {\r\n    day.runningTotal = data[idx - 1] ? data[idx - 1].runningTotal : 0;\r\n    day.runningTotal += day.Archie;\r\n    day.runningTotal -= day.Ben;\r\n  });\r\n\r\n  const runningData = data.map((e) => e.runningTotal);\r\n\r\n  codData.runningView = { runningData, labels };\r\n\r\n  const totalArchie = _.sumBy(data, \"Archie\");\r\n  document.getElementById(\"numGamesArchie\").innerHTML = totalArchie;\r\n  const totalBen = _.sumBy(data, \"Ben\");\r\n  document.getElementById(\"numGamesBen\").innerHTML = totalBen;\r\n  // console.log(data);\r\n\r\n  const dateOfLastTest = moment(data[data.length - 1].Date, \"DD/MM/YYYY\").hour(\r\n    8\r\n  );\r\n\r\n  // console.log(dateOfLastTest.unix());\r\n  // console.log(new Date().getTime());\r\n\r\n  const timeSinceLastTest = new Date().getTime() / 1000 - dateOfLastTest.unix();\r\n\r\n  // console.log(timeSinceLastTest);\r\n\r\n  const dateOfLastTestMessage =\r\n    dateOfLastTest.format(\"Do [of] MMMM\") +\r\n    \" (\" +\r\n    (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.createTimeMessage)(timeSinceLastTest) +\r\n    \" ago)\";\r\n\r\n  document.getElementById(\"timeSinceLastCod\").innerHTML = dateOfLastTestMessage;\r\n}\r\n\r\nfunction updateCodNormal() {\r\n  const { dataArchie, dataBen, labels } = codData.normalView;\r\n\r\n  codChart.data.labels = labels;\r\n  codChart.data.datasets = [\r\n    {\r\n      label: \"Archie\",\r\n      data: dataArchie,\r\n      backgroundColor: \"#8ecae6\",\r\n      tension: 0.1,\r\n      fill: true,\r\n    },\r\n    {\r\n      label: \"Ben\",\r\n      data: dataBen,\r\n      backgroundColor: \"#F4A4A4\",\r\n      tension: 0.1,\r\n      fill: true,\r\n    },\r\n  ];\r\n\r\n  codChart.options.scales.y = {\r\n    title: {\r\n      text: \"Score\",\r\n      display: true,\r\n    },\r\n    ticks: {\r\n      beginAtZero: true,\r\n      callback: function (value, index, values) {\r\n        if (value % 1 == 0) {\r\n          return Math.abs(value);\r\n        }\r\n      },\r\n    },\r\n  };\r\n\r\n  codChart.options.plugins.legend = {\r\n    labels: {\r\n      filter: (item) => item.text !== \"Margin\",\r\n    },\r\n    display: true,\r\n  };\r\n  codChart.update();\r\n}\r\n\r\nfunction updateCodRunning() {\r\n  const { runningData, labels } = codData.runningView;\r\n  codChart.data.labels = labels;\r\n  codChart.data.datasets = [\r\n    {\r\n      label: \"Margin\",\r\n      data: runningData,\r\n      showLine: false,\r\n\r\n      fill: {\r\n        target: \"origin\",\r\n        above: \"#8ecae6\", // Area will be red above the origin\r\n        below: \"#F4A4A4\", // And blue below the origin\r\n      },\r\n      pointBackgroundColor: function (context) {\r\n        var index = context.dataIndex;\r\n        var value = context.dataset.data[index];\r\n        return value > 0 ? \"#8ecae6\" : value < 0 ? \"#F4A4A4\" : \"#000000\";\r\n      },\r\n      pointBorderColor: function (context) {\r\n        var index = context.dataIndex;\r\n        var value = context.dataset.data[index];\r\n        return value > 0 ? \"#8ecae6\" : value < 0 ? \"#F4A4A4\" : \"#000000\";\r\n      },\r\n    },\r\n    { label: \"Archie\", data: [], backgroundColor: \"#8ecae6\" },\r\n    { label: \"Ben\", data: [], backgroundColor: \"#F4A4A4\" },\r\n  ];\r\n\r\n  codChart.options.scales.y = {\r\n    title: {\r\n      text: \"Winning margin\",\r\n      display: true,\r\n    },\r\n    ticks: {\r\n      beginAtZero: true,\r\n      callback: function (value, index, values) {\r\n        if (value % 1 == 0) {\r\n          return Math.abs(value);\r\n        }\r\n      },\r\n    },\r\n  };\r\n\r\n  codChart.options.plugins.legend = {\r\n    labels: {\r\n      filter: (item) => item.text !== \"Margin\",\r\n    },\r\n    display: true,\r\n  };\r\n  // codChart.options.plugins.legend = {\r\n  //   display: false,\r\n  // };\r\n\r\n  codChart.update();\r\n}\r\n\r\nfunction drawCodChart() {\r\n  let ctx = document.getElementById(\"CODChart\").getContext(\"2d\");\r\n\r\n  codChart = new Chart(ctx, {\r\n    type: \"line\",\r\n\r\n    options: {\r\n      maintainAspectRatio: true,\r\n      responsive: true,\r\n\r\n      plugins: {\r\n        legend: {\r\n          display: true,\r\n        },\r\n        tooltip: {\r\n          mode: \"index\",\r\n          intersect: false,\r\n          callbacks: {\r\n            label: function (context) {\r\n              let label = context.dataset.label || \"\";\r\n\r\n              if (label) {\r\n                label += \": \";\r\n              }\r\n              if (context.parsed.y !== null) {\r\n                label += \" \" + Math.abs(context.parsed.y);\r\n              }\r\n              return label;\r\n            },\r\n          },\r\n        },\r\n      },\r\n      scales: {\r\n        x: {\r\n          ticks: {\r\n            maxTicksLimit: 4,\r\n          },\r\n        },\r\n\r\n        y: {\r\n          ticks: {\r\n            beginAtZero: true,\r\n            callback: function (value, index, values) {\r\n              if (value % 1 == 0) {\r\n                return Math.abs(value);\r\n              }\r\n            },\r\n          },\r\n        },\r\n      },\r\n    },\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/cod.js?");

/***/ }),

/***/ "./src/dobble.js":
/*!***********************!*\
  !*** ./src/dobble.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usefullFunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usefullFunc */ \"./src/usefullFunc.js\");\n\r\n\r\nlet dobbleToggleState = 0;\r\nlet dobbleData = {};\r\nlet dobbleChart;\r\nlet config;\r\n\r\nfunction switchdobbleDots() {\r\n  let circles = Array.from(document.getElementsByClassName(\"dobbleCircles\"));\r\n  let desc = document.getElementById(\"dobbleDesc\");\r\n\r\n  switch (dobbleToggleState) {\r\n    case 0:\r\n      desc.innerHTML =\r\n        'I made <a href=\"https://dobble.artomweb.com\">this</a> game to see if I can get better at playing Dobble. Can you beat my score?';\r\n      break;\r\n    case 1:\r\n      desc.innerHTML =\r\n        \"This graph shows my average score at each hour of the day.\";\r\n      break;\r\n  }\r\n  circles.forEach((c) =>\r\n    c.id.slice(-1) == dobbleToggleState\r\n      ? (c.style.fill = \"black\")\r\n      : (c.style.fill = \"none\")\r\n  );\r\n}\r\n\r\nfunction dobbleToggle() {\r\n  switchdobbleDots();\r\n  switch (dobbleToggleState) {\r\n    case 0:\r\n      updatedobbleNormal();\r\n      break;\r\n\r\n    case 1:\r\n      updatedobblePerHour();\r\n      break;\r\n  }\r\n  dobbleToggleState == 1 ? (dobbleToggleState = 0) : dobbleToggleState++;\r\n}\r\nfunction fetchDobble() {\r\n  const primaryUrl = \"https://api.artomweb.com/cache/dobble\";\r\n  const fallbackUrl =\r\n    \"https://docs.google.com/spreadsheets/d/e/2PACX-1vQwLrwjE_FFzRj2Sq9S3-8MQDfpnGchacJGkM1s6Oidsswu82E4jBewlVWCNA4CwW9K3EauyYYlNfTL/pub?output=csv\";\r\n\r\n  function parseCSV(url) {\r\n    Papa.parse(url, {\r\n      download: true,\r\n      header: true,\r\n      complete: function (results) {\r\n        try {\r\n          processDobble(results.data);\r\n        } catch (error) {\r\n          console.log(\"Error processing dobble data:\", error);\r\n          if (url !== fallbackUrl) {\r\n            console.log(\"Trying the fallback URL...\");\r\n            parseCSV(fallbackUrl);\r\n          } else {\r\n            let dobbleCard = document.getElementById(\"dobbleCard\");\r\n            dobbleCard.style.display = \"none\";\r\n          }\r\n        }\r\n      },\r\n      error: function (error) {\r\n        console.log(\"Failed to fetch dobble data from:\", url);\r\n        if (url === primaryUrl) {\r\n          console.log(\"Trying the fallback URL...\");\r\n          parseCSV(fallbackUrl);\r\n        } else {\r\n          let dobbleCard = document.getElementById(\"dobbleCard\");\r\n          dobbleCard.style.display = \"none\";\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  // Try to fetch data from the primary URL first\r\n  parseCSV(primaryUrl);\r\n}\r\n\r\nfetchDobble();\r\n\r\nfunction updatedobbleNormal() {\r\n  const { labels, data } = dobbleData;\r\n\r\n  dobbleChart.options.scales.x = {\r\n    ticks: {\r\n      autoSkip: true,\r\n      maxTicksLimit: 5.1,\r\n    },\r\n  };\r\n\r\n  dobbleChart.options.scales.y = {\r\n    title: {\r\n      text: \"Average Score\",\r\n      display: true,\r\n    },\r\n    beginAtZero: true,\r\n  };\r\n\r\n  dobbleChart.options.plugins.tooltip.callbacks.title = function (tooltipItem) {\r\n    return tooltipItem[0].label;\r\n  };\r\n\r\n  dobbleChart.data.labels = labels;\r\n  dobbleChart.data.datasets = [\r\n    {\r\n      data: data,\r\n      backgroundColor: \"#8ecae6\",\r\n      tension: 0.1,\r\n      fill: true,\r\n    },\r\n  ];\r\n\r\n  dobbleChart.update();\r\n}\r\n\r\nfunction updatedobblePerHour() {\r\n  const { timOfDayLabels, timOfDayData, pointRadiusArray } = dobbleData;\r\n\r\n  dobbleChart.options.scales.x = {\r\n    type: \"linear\",\r\n    position: \"bottom\",\r\n    ticks: {\r\n      stepSize: 1,\r\n      callback: function (value, index, values) {\r\n        return `${value}:00`;\r\n      },\r\n    },\r\n  };\r\n\r\n  dobbleChart.options.scales.y = {\r\n    title: {\r\n      text: \"Average score\",\r\n      display: true,\r\n    },\r\n    beginAtZero: true,\r\n  };\r\n\r\n  dobbleChart.options.plugins.tooltip.callbacks.title = function (tooltipItem) {\r\n    return tooltipItem[0].label + \":00\";\r\n  };\r\n\r\n  dobbleChart.data.labels = timOfDayLabels;\r\n  dobbleChart.data.datasets = [\r\n    {\r\n      data: timOfDayData,\r\n      backgroundColor: \"#8ecae6\",\r\n      tension: 0.1,\r\n      fill: true,\r\n      pointRadius: pointRadiusArray,\r\n    },\r\n  ];\r\n\r\n  dobbleChart.update();\r\n}\r\n\r\nfunction processDobble(dataIn) {\r\n  updateDobbleData(dataIn);\r\n\r\n  plotDobble();\r\n\r\n  dobbleToggle();\r\n}\r\n\r\nfunction updateDobbleData(dataIn) {\r\n  let totalTime = 0;\r\n  dataIn.forEach((elt) => {\r\n    elt.timestamp = new Date(+elt.unix * 1000);\r\n    elt.score = +elt.score;\r\n    totalTime += +elt.testTime;\r\n  });\r\n\r\n  const numTests = dataIn.length;\r\n\r\n  let weekAvg = _.chain(dataIn)\r\n    .groupBy((d) => {\r\n      return moment(d.timestamp).format(\"MMM YY\");\r\n    })\r\n    .map((entries, mofy) => {\r\n      return {\r\n        mofy,\r\n        avg: Math.round(_.meanBy(entries, (entry) => entry.score) * 10) / 10,\r\n        // avg: Math.round(_.maxBy(entries, \"score\").score * 10) / 10,\r\n      };\r\n    })\r\n    .value();\r\n\r\n  const labels = weekAvg.map((el) => el.mofy);\r\n  const data = weekAvg.map((el) => el.avg);\r\n\r\n  const hoursOfDay = Array.from({ length: 24 }, (_, i) =>\r\n    i.toString().padStart(2, \"0\")\r\n  );\r\n\r\n  const byTimeOfDay = _.chain(dataIn)\r\n    .groupBy((d) => {\r\n      return moment(d.timestamp).format(\"HH\");\r\n    })\r\n    .map((entries, hour) => {\r\n      return {\r\n        hour: +hour,\r\n        avg: Math.round(_.meanBy(entries, (entry) => +entry.score) * 10) / 10,\r\n        // avg: Math.round(_.maxBy(entries, \"score\").score * 10) / 10,\r\n        // avg: entries.length,\r\n      };\r\n    })\r\n    .sortBy((d) => d.hour)\r\n    .value();\r\n\r\n  console.log(byTimeOfDay);\r\n\r\n  const completedByTimeOfDay = _.map(hoursOfDay, (hour) => {\r\n    const existingHourData = byTimeOfDay.find(\r\n      (item) => item.hour === parseInt(hour)\r\n    );\r\n    return existingHourData || { hour: +hour, avg: 0 };\r\n  });\r\n\r\n  const timOfDayLabels = completedByTimeOfDay.map((item) => item.hour);\r\n  const timOfDayData = completedByTimeOfDay.map((item) => item.avg);\r\n\r\n  const pointRadiusArray = completedByTimeOfDay.map((item) =>\r\n    item.avg !== 0 ? 3 : 0\r\n  );\r\n\r\n  let scorePoints = dataIn.map((point) => +point.score);\r\n\r\n  const trend = (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.findLineByLeastSquares)(scorePoints);\r\n\r\n  const scoreChange = trend[1][1] - trend[0][1];\r\n\r\n  const delta = dataIn.length * 60;\r\n\r\n  const changeInScorePerMinSigned = (scoreChange * (3600 / delta)).toFixed(2);\r\n\r\n  const PorNchange = changeInScorePerMinSigned > 0 ? \"+\" : \"-\";\r\n\r\n  const changeInScorePerMin = Math.abs(changeInScorePerMinSigned);\r\n\r\n  const maxScore = _.maxBy(dataIn, \"score\").score;\r\n  const timeMessage = Math.round(totalTime / (60 * 60)) + \" hours\";\r\n\r\n  const dateOfLastTest = moment(dataIn[dataIn.length - 1].timestamp).format(\r\n    \"Do [of] MMMM\"\r\n  );\r\n\r\n  const timeSinceLastTest =\r\n    (new Date().getTime() - dataIn[dataIn.length - 1].timestamp.getTime()) /\r\n    1000;\r\n\r\n  const dateOfLastTestMessage =\r\n    dateOfLastTest + \" (\" + (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.createTimeMessage)(timeSinceLastTest) + \" ago)\";\r\n\r\n  document.getElementById(\"dobbleScoreChangePerHour\").innerHTML =\r\n    PorNchange + changeInScorePerMin;\r\n\r\n  document.getElementById(\"dobbleTime\").innerHTML = timeMessage;\r\n\r\n  document.getElementById(\"highestDobble\").innerHTML = maxScore;\r\n  document.getElementById(\"numberDobble\").innerHTML = numTests;\r\n\r\n  document.getElementById(\"timeSinceLastDobble\").innerHTML =\r\n    dateOfLastTestMessage;\r\n\r\n  dobbleData = {\r\n    labels,\r\n    data,\r\n    timOfDayLabels,\r\n    timOfDayData,\r\n    pointRadiusArray,\r\n  };\r\n\r\n  // console.log(maxScore);\r\n}\r\n\r\nfunction plotDobble() {\r\n  let ctx = document.getElementById(\"dobbleChart\").getContext(\"2d\");\r\n\r\n  config = {\r\n    type: \"line\",\r\n    data: {\r\n      // labels: labels,\r\n      // datasets: [\r\n      //   {\r\n      //     tension: 0.3,\r\n      //     // borderColor: \"black\",\r\n      //     data: data,\r\n      //     backgroundColor: \"#8ecae6\",\r\n      //     fill: true,\r\n      //   },\r\n      // ],\r\n    },\r\n\r\n    options: {\r\n      maintainAspectRatio: true,\r\n      responsive: true,\r\n\r\n      plugins: {\r\n        legend: {\r\n          display: false,\r\n        },\r\n        tooltip: {\r\n          callbacks: {\r\n            label: function (context) {\r\n              let label = context.dataset.label || \"\";\r\n\r\n              if (label) {\r\n                label += \": \";\r\n              }\r\n              if (context.parsed.y !== null) {\r\n                label += \"Average: \" + context.parsed.y;\r\n              }\r\n              return label;\r\n            },\r\n\r\n            title: function (context) {\r\n              let title = context[0].label;\r\n              return title;\r\n            },\r\n          },\r\n        },\r\n      },\r\n      scales: {\r\n        y: {\r\n          title: {\r\n            text: \"Average score\",\r\n            display: true,\r\n          },\r\n          beginAtZero: true,\r\n          ticks: {\r\n            stepSize: 1,\r\n          },\r\n        },\r\n\r\n        x: {\r\n          ticks: {\r\n            autoSkip: true,\r\n            maxTicksLimit: 5.1,\r\n          },\r\n        },\r\n      },\r\n    },\r\n  };\r\n  dobbleChart = new Chart(ctx, config);\r\n}\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/dobble.js?");

/***/ }),

/***/ "./src/driving.js":
/*!************************!*\
  !*** ./src/driving.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usefullFunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usefullFunc */ \"./src/usefullFunc.js\");\n\r\n\r\nfunction fetchDriving() {\r\n  const primaryUrl = \"https://api.artomweb.com/cache/driving\";\r\n  const fallbackUrl =\r\n    \"https://docs.google.com/spreadsheets/d/e/2PACX-1vSlFhe-8wZDuYkepfvfo3g0uP4OEFh-r1PFkqaf_M73SyphJD8sSVIWsJ17-B2z-Hfu8MscZ8TfB9K8/pub?output=csv\";\r\n\r\n  function parseCSV(url) {\r\n    Papa.parse(url, {\r\n      download: true,\r\n      header: true,\r\n      complete: function (results) {\r\n        try {\r\n          processDriving(results.data);\r\n        } catch (error) {\r\n          console.log(\"Error processing driving data:\", error);\r\n          if (url !== fallbackUrl) {\r\n            console.log(\"Trying the fallback URL...\");\r\n            parseCSV(fallbackUrl);\r\n          } else {\r\n            let drivingCard = document.getElementById(\"drivingCard\");\r\n            drivingCard.style.display = \"none\";\r\n          }\r\n        }\r\n      },\r\n      error: function (error) {\r\n        console.log(\"Failed to fetch driving data from:\", url);\r\n        if (url === primaryUrl) {\r\n          console.log(\"Trying the fallback URL...\");\r\n          parseCSV(fallbackUrl);\r\n        } else {\r\n          let drivingCard = document.getElementById(\"drivingCard\");\r\n          drivingCard.style.display = \"none\";\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  // Try to fetch data from the primary URL first\r\n  parseCSV(primaryUrl);\r\n}\r\n\r\nfetchDriving();\r\n\r\nfunction showdrivingSymbols() {\r\n  let symbols = document.getElementsByClassName(\"drivingSymbol\");\r\n\r\n  for (let s of symbols) {\r\n    s.style.display = \"inline\";\r\n  }\r\n}\r\n\r\nfunction processDriving(data) {\r\n  showdrivingSymbols();\r\n  let totalMiles = _.sumBy(data, function (o) {\r\n    return +o.totalMiles;\r\n  });\r\n  let totalSeconds = _.sumBy(data, function (o) {\r\n    return +o.totalSeconds;\r\n  });\r\n\r\n  let timeDriving = document.getElementById(\"timeDriving\");\r\n  let milesDriven = document.getElementById(\"milesDriven\");\r\n\r\n  let timeMessage = Math.round(totalSeconds / (60 * 60)) + \" hours\";\r\n\r\n  timeDriving.innerHTML = timeMessage;\r\n  milesDriven.innerHTML = totalMiles.toFixed(1);\r\n\r\n  let sortedData = data.sort(function (a, b) {\r\n    return b.startTimestamp - a.startTimestamp;\r\n  });\r\n\r\n  let dateOfLastDrive = moment\r\n    .unix(sortedData[0].endTimestamp / 1000)\r\n    .format(\"Do [of] MMMM\");\r\n\r\n  let timeSinceLastDrive =\r\n    (new Date().getTime() - sortedData[0].endTimestamp) / 1000;\r\n\r\n  let dateOfLastDriveMessage =\r\n    dateOfLastDrive + \" (\" + (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.createTimeMessage)(timeSinceLastDrive) + \" ago)\";\r\n\r\n  document.getElementById(\"timeSinceLastDrive\").innerHTML =\r\n    dateOfLastDriveMessage;\r\n}\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/driving.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usefullFunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usefullFunc */ \"./src/usefullFunc.js\");\n/* harmony import */ var _cats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cats */ \"./src/cats.js\");\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chess */ \"./src/chess.js\");\n/* harmony import */ var _cod__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cod */ \"./src/cod.js\");\n/* harmony import */ var _dobble__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dobble */ \"./src/dobble.js\");\n/* harmony import */ var _driving__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./driving */ \"./src/driving.js\");\n/* harmony import */ var _moreStats__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./moreStats */ \"./src/moreStats.js\");\n/* harmony import */ var _rppiSocket__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rppiSocket */ \"./src/rppiSocket.js\");\n/* harmony import */ var _spotifyChart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./spotifyChart */ \"./src/spotifyChart.js\");\n/* harmony import */ var _typingSpeed__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./typingSpeed */ \"./src/typingSpeed.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// fix button animation on mobile\r\nlet touchButtons = document.querySelectorAll(\".button\");\r\n\r\ntouchButtons.forEach((but) => {\r\n  but.addEventListener(\"touchstart\", function (e) {\r\n    but.classList.add(\"active\");\r\n    setTimeout(function () {\r\n      but.classList.remove(\"active\");\r\n    }, 200);\r\n  });\r\n});\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/index.js?");

/***/ }),

/***/ "./src/moreStats.js":
/*!**************************!*\
  !*** ./src/moreStats.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usefullFunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usefullFunc */ \"./src/usefullFunc.js\");\n\r\n\r\n// let timeAlive = document.getElementById(\"timeAlive\");\r\nlet timeDriving = document.getElementById(\"timeAbleDrive\");\r\n// let timeWithPhone = document.getElementById(\"timePhone\");\r\n// let beginningOfAllTime = new Date(1050631200 * 1000);\r\nlet drivingPass = new Date(1626864660 * 1000);\r\n// let getPhone = new Date(1582210140 * 1000);\r\nlet nowTime;\r\n\r\nfunction updateTexts() {\r\n  nowTime = new Date();\r\n\r\n  // let ageDelta = (nowTime.getTime() - beginningOfAllTime.getTime()) / 1000;\r\n  let drivingDelta = (nowTime.getTime() - drivingPass.getTime()) / 1000;\r\n  // let phoneDelta = (nowTime.getTime() - getPhone.getTime()) / 1000;\r\n\r\n  // let ageMessage = createTimeMessage(ageDelta);\r\n  let drivingMessage = (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.createTimeMessage)(drivingDelta);\r\n  // let phoneMessage = createTimeMessage(phoneDelta);\r\n\r\n  // console.log(drivingDelta);\r\n  // timeAlive.innerHTML = ageMessage;\r\n  timeDriving.innerHTML = drivingMessage;\r\n  // timeWithPhone.innerHTML = phoneMessage;\r\n}\r\n\r\nupdateTexts();\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/moreStats.js?");

/***/ }),

/***/ "./src/rppiSocket.js":
/*!***************************!*\
  !*** ./src/rppiSocket.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usefullFunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usefullFunc */ \"./src/usefullFunc.js\");\n\r\n\r\nlet socket = io(\"https://api.artomweb.com/reading\", {\r\n  reconnectionDelay: 500,\r\n});\r\n\r\nlet tempIcon = document.getElementById(\"tempIcon\");\r\nlet pressIcon = document.getElementById(\"pressIcon\");\r\nlet humidIcon = document.getElementById(\"humidIcon\");\r\n\r\nlet temperatureReading = document.getElementById(\"temperatureReading\");\r\nlet pressureReading = document.getElementById(\"pressureReading\");\r\nlet humidityReading = document.getElementById(\"humidityReading\");\r\n\r\nfunction updateReadingText(msg) {\r\n  document.getElementById(\"liveDataCard\").classList.remove(\"hidden\");\r\n  temperatureReading.innerHTML = msg.temperature.toFixed(2);\r\n  pressureReading.innerHTML = msg.pressure.toFixed(2);\r\n  if (!msg.humidity) {\r\n    document.getElementById(\"humid\").style.display = \"none\";\r\n  } else {\r\n    humidityReading.innerHTML = msg.humidity.toFixed(2);\r\n  }\r\n\r\n  // console.log(\"Temp classes\", tempIcon.classList);\r\n\r\n  let icons = [\r\n    [\"temperature\", tempIcon],\r\n    [\"pressure\", pressIcon],\r\n    [\"humidity\", humidIcon],\r\n  ];\r\n\r\n  // console.log(msg);\r\n\r\n  if (msg.averages) {\r\n    icons.map(([name, icon]) => {\r\n      if (msg[name] >= msg.averages[name]) {\r\n        if (icon.classList !== undefined) {\r\n          if (icon.classList.contains(\"fa-caret-down\"))\r\n            icon.classList.remove(\"fa-caret-down\");\r\n          if (!icon.classList.contains(\"fa-caret-up\"))\r\n            icon.classList.add(\"fa-caret-up\");\r\n        } else {\r\n          icon.classList.add(\"fa-caret-up\");\r\n        }\r\n      } else {\r\n        if (icon.classList !== undefined) {\r\n          if (icon.classList.contains(\"fa-caret-up\"))\r\n            icon.classList.remove(\"fa-caret-up\");\r\n          if (!icon.classList.contains(\"fa-caret-down\"))\r\n            icon.classList.add(\"fa-caret-down\");\r\n        } else {\r\n          icon.classList.add(\"fa-caret-down\");\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction showDataSymbols() {\r\n  let symbols = document.getElementsByClassName(\"liveDataSymbol\");\r\n\r\n  for (let s of symbols) {\r\n    s.style.display = \"inline\";\r\n  }\r\n}\r\nsocket.on(\"new data\", function (msg) {\r\n  updateReadingText(msg);\r\n});\r\n\r\nsocket.on(\"server init\", function (msg) {\r\n  if (\"lastData\" in msg) {\r\n    updateReadingText(msg.lastData);\r\n  }\r\n  showDataSymbols();\r\n  let serverInit = new Date(msg.serverInitTime);\r\n  let currentTime = new Date();\r\n\r\n  // console.log(msg.serverInitTime, serverInit, currentTime);\r\n\r\n  let delta = Math.abs(currentTime - serverInit) / 1000;\r\n\r\n  let message = (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.createTimeMessage)(delta);\r\n\r\n  document.getElementById(\"serverUpTime\").innerHTML = message;\r\n});\r\n\r\nsocket.on(\"connect\", function () {\r\n  document.getElementById(\"liveText\").style.color = \"red\";\r\n});\r\n\r\nsocket.on(\"disconnect\", function () {\r\n  document.getElementById(\"liveText\").style.color = \"black\";\r\n});\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/rppiSocket.js?");

/***/ }),

/***/ "./src/spotifyChart.js":
/*!*****************************!*\
  !*** ./src/spotifyChart.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usefullFunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usefullFunc */ \"./src/usefullFunc.js\");\n\r\nlet spotifyData;\r\nlet mySpotifyChart;\r\nlet config;\r\nlet toggleState = 0;\r\nlet ctx2;\r\nlet backgroundColor = \"#81b29a\";\r\n\r\nfunction getPapaParseSpotify() {\r\n  const primaryUrl = \"https://api.artomweb.com/cache/spotify\";\r\n  const fallbackUrl =\r\n    \"https://docs.google.com/spreadsheets/d/e/2PACX-1vSw3m_yyTByllweTNnIM13oR_P4RSXG2NpF3jfYKpmPtsS8a_s8qA7YIOdzaRgl6h5b2TSaY5ohuh6J/pub?output=csv\";\r\n\r\n  function parseCSV(url) {\r\n    Papa.parse(url, {\r\n      download: true,\r\n      header: true,\r\n      complete: function (results) {\r\n        try {\r\n          parseSpotify(results.data);\r\n        } catch (error) {\r\n          console.log(\"Error processing data from:\", url);\r\n          if (url !== fallbackUrl) {\r\n            console.log(\"Trying the fallback URL...\");\r\n            parseCSV(fallbackUrl);\r\n          } else {\r\n            let spotifyCard = document.getElementById(\"spotifyCard\");\r\n            spotifyCard.style.display = \"none\";\r\n          }\r\n        }\r\n      },\r\n      error: function (error) {\r\n        console.log(\"Failed to fetch data from:\", url);\r\n        if (url === primaryUrl) {\r\n          console.log(\"Trying the fallback URL...\");\r\n          parseCSV(fallbackUrl);\r\n        } else {\r\n          let spotifyCard = document.getElementById(\"spotifyCard\");\r\n          spotifyCard.style.display = \"none\";\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  // Try to fetch data from the primary URL first\r\n  parseCSV(primaryUrl);\r\n}\r\n\r\ngetPapaParseSpotify();\r\n\r\n// changes the description to the relevant text and changes the fill of the circles\r\nfunction switchSpotifyDots() {\r\n  let circles = Array.from(document.getElementsByClassName(\"spotifyCircles\"));\r\n  let desc = document.getElementById(\"spotify-desc\");\r\n\r\n  switch (toggleState) {\r\n    case 0:\r\n      desc.innerHTML = \"On average, which days do I listen to the most music\";\r\n      break;\r\n    case 1:\r\n      desc.innerHTML =\r\n        \"How many songs have I listened to in the last two weeks\";\r\n      break;\r\n    case 2:\r\n      desc.innerHTML = \"Each month, for the last two years\";\r\n      break;\r\n  }\r\n  circles.forEach((c) =>\r\n    c.id.slice(-1) == toggleState\r\n      ? (c.style.fill = \"black\")\r\n      : (c.style.fill = \"none\")\r\n  );\r\n}\r\n\r\n// updates the chart, calls the function to update the text and switch the dots and LASTLY increments the toggleState\r\nfunction spotifyToggle() {\r\n  switchSpotifyDots();\r\n  switch (toggleState) {\r\n    case 0:\r\n      updateByDay();\r\n      break;\r\n\r\n    case 1:\r\n      updateTwoWeeks();\r\n      break;\r\n\r\n    case 2:\r\n      updateAllData();\r\n      break;\r\n  }\r\n  toggleState == 2 ? (toggleState = 0) : toggleState++;\r\n}\r\n\r\nfunction parseSpotify(dataIn) {\r\n  spotifyData = updateSpotify(dataIn);\r\n\r\n  spotifyChart();\r\n  spotifyToggle();\r\n}\r\n\r\nfunction createDatabase(dataIn) {\r\n  let dataOut = {};\r\n  dataOut.lastTwoWeeks = getLastTwoWeeks(dataIn);\r\n  return dataOut;\r\n}\r\n\r\n// update the chart to show the data, aggregated by day, BAR CHART\r\nfunction updateByDay() {\r\n  const { data, labels } = spotifyData.byDay;\r\n\r\n  mySpotifyChart.destroy();\r\n  let temp = { ...config };\r\n\r\n  temp.type = \"bar\";\r\n\r\n  temp.data.labels = labels;\r\n\r\n  let newDataset = {\r\n    // tension: 0.3,\r\n    // borderColor: \"black\",\r\n    data: data,\r\n    backgroundColor,\r\n    // fill: false,\r\n  };\r\n  temp.data.datasets = [newDataset];\r\n\r\n  temp.options.scales.x = { offset: true };\r\n\r\n  mySpotifyChart.options.scales.y = {\r\n    title: {\r\n      text: \"Average songs played\",\r\n      display: true,\r\n    },\r\n  };\r\n\r\n  mySpotifyChart = new Chart(ctx2, temp);\r\n}\r\n\r\n// update the chart to show the data, for the last two weeks, LIN CHART\r\nfunction updateTwoWeeks() {\r\n  let { data, labels } = spotifyData.lastTwoWeeks;\r\n\r\n  labels = labels.map((l) => new Date(l));\r\n\r\n  let newDataset = {\r\n    tension: 0.3,\r\n    // borderColor: \"black\",\r\n    data: data,\r\n    backgroundColor,\r\n    fill: true,\r\n  };\r\n\r\n  mySpotifyChart.destroy();\r\n  let temp = { ...config };\r\n\r\n  temp.type = \"line\";\r\n\r\n  temp.data.labels = labels;\r\n\r\n  temp.data.datasets = [newDataset];\r\n\r\n  temp.options.scales = {\r\n    x: {\r\n      ticks: {\r\n        maxTicksLimit: 6.3,\r\n      },\r\n      type: \"time\",\r\n      time: {\r\n        tooltipFormat: \"dd-MM-yyyy\",\r\n      },\r\n    },\r\n\r\n    y: {\r\n      title: {\r\n        text: \"Total songs played\",\r\n        display: true,\r\n      },\r\n      ticks: {\r\n        beginAtZero: true,\r\n      },\r\n    },\r\n  };\r\n\r\n  mySpotifyChart = new Chart(ctx2, temp);\r\n}\r\n\r\n// update the chart to show the data, aggregated by week, LINE CHART\r\nfunction updateAllData() {\r\n  let { data, labels } = spotifyData.byWeek;\r\n  let newDataset = {\r\n    // tension: 0.3,\r\n    // borderColor: \"black\",\r\n    data: data,\r\n    backgroundColor,\r\n    fill: true,\r\n  };\r\n  // console.log(values);\r\n\r\n  mySpotifyChart.data.labels = labels;\r\n\r\n  mySpotifyChart.data.datasets = [newDataset];\r\n\r\n  mySpotifyChart.options.scales = {\r\n    x: {\r\n      ticks: {\r\n        autoSkip: true,\r\n        maxTicksLimit: 4,\r\n        maxRotation: 0,\r\n        minRotation: 0,\r\n      },\r\n    },\r\n  };\r\n\r\n  mySpotifyChart.options.scales.y = {\r\n    title: {\r\n      text: \"Total songs played\",\r\n      display: true,\r\n    },\r\n  };\r\n\r\n  //   console.log(mySpotifyChart.data.datasets);\r\n\r\n  mySpotifyChart.update();\r\n}\r\n\r\n// plot the template chart\r\nfunction spotifyChart() {\r\n  // let rawData = [589, 445, 483, 503, 689, 692, 634];\r\n  // let labels = [\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"];\r\n\r\n  //   console.log(currData);\r\n\r\n  ctx2 = document.getElementById(\"spotifyChart\").getContext(\"2d\");\r\n  config = {\r\n    type: \"line\",\r\n    data: {\r\n      // labels: labels,\r\n      datasets: [\r\n        {\r\n          // tension: 0.3,\r\n          // borderColor: \"black\",\r\n          // data: rawData,\r\n          backgroundColor,\r\n          // fill: false,\r\n        },\r\n      ],\r\n    },\r\n\r\n    options: {\r\n      maintainAspectRatio: true,\r\n      responsive: true,\r\n\r\n      plugins: {\r\n        legend: {\r\n          display: false,\r\n        },\r\n        tooltip: {\r\n          callbacks: {\r\n            label: function (context) {\r\n              let label = context.dataset.label || \"\";\r\n\r\n              if (label) {\r\n                label += \": \";\r\n              }\r\n              if (context.parsed.y !== null) {\r\n                if (toggleState == 1) {\r\n                  label += context.parsed.y + \" average\";\r\n                } else {\r\n                  label += context.parsed.y + \" songs\";\r\n                }\r\n              }\r\n              return label;\r\n            },\r\n\r\n            title: function (context) {\r\n              let title = context[0].label;\r\n              if (toggleState == 1) {\r\n                title = moment(title, \"dd\").format(\"dddd\");\r\n              }\r\n\r\n              return title;\r\n            },\r\n          },\r\n        },\r\n      },\r\n      scales: {\r\n        y: {\r\n          beginAtZero: true,\r\n          // ticks: {\r\n          // min: 5,\r\n          // },\r\n        },\r\n      },\r\n    },\r\n  };\r\n  mySpotifyChart = new Chart(ctx2, config);\r\n}\r\n\r\nfunction getLastTwoWeeks(dat) {\r\n  let rawLabels = dat.map((e) => {\r\n    return e.Date;\r\n  });\r\n\r\n  let rawData = dat.map((e) => {\r\n    return e.Value;\r\n  });\r\n\r\n  let data = rawData.slice(0, 14);\r\n  let labels = rawLabels.slice(0, 14);\r\n\r\n  return { data, labels };\r\n}\r\n\r\nfunction getAllWeeks(dat) {\r\n  let twoYearsAgo = moment().subtract(3, \"years\");\r\n  dat = dat.filter((d) => {\r\n    return moment(d.Date).isSameOrAfter(twoYearsAgo);\r\n  });\r\n  let weekAvg = _.chain(dat)\r\n    .groupBy((d) => {\r\n      return moment(d.Date).format(\"MMM-YYYY\");\r\n    })\r\n    .map((entries, week) => ({\r\n      wofy: week,\r\n      avg: _.sumBy(entries, (entry) => +entry.Value),\r\n    }))\r\n    .value();\r\n\r\n  weekAvg.sort(\r\n    (a, b) => moment(a.wofy, \"MMM-YYYY\") - moment(b.wofy, \"MMM-YYYY\")\r\n  );\r\n\r\n  let labels = weekAvg.map((w) => w.wofy);\r\n  let data = weekAvg.map((w) => w.avg);\r\n\r\n  return { data, labels };\r\n}\r\n\r\nfunction getByDay(dat) {\r\n  let totalAvgs = _.chain(dat)\r\n    .map((d) => {\r\n      let day = moment(d.Date).format(\"dd\");\r\n      return { ...d, dofw: day };\r\n    })\r\n    .groupBy(\"dofw\")\r\n    .map((entries, day) => ({\r\n      dofw: day,\r\n      avg: Math.round(_.meanBy(entries, (entry) => entry.Value)),\r\n    }))\r\n    .value();\r\n\r\n  totalAvgs = _.sortBy(totalAvgs, (o) => {\r\n    return moment(o.dofw, \"dd\").isoWeekday();\r\n  });\r\n\r\n  let labels = totalAvgs.map((val) => val.dofw);\r\n  let data = totalAvgs.map((val) => val.avg);\r\n\r\n  return { data, labels };\r\n}\r\n\r\nfunction parseSpotifyDates(results) {\r\n  let dateParse = results.map((elem) => {\r\n    return {\r\n      Date: new Date(elem.Date),\r\n      Value: +elem.Value,\r\n    };\r\n  });\r\n\r\n  spotifyData = dateParse.sort(function (a, b) {\r\n    return b.Date.getTime() - a.Date.getTime();\r\n  });\r\n\r\n  return spotifyData;\r\n}\r\n\r\nfunction updateSpotify(dataIn) {\r\n  let parsed = parseSpotifyDates(dataIn);\r\n\r\n  let dateOfLastTest = moment(parsed[0].Date).format(\"Do [of] MMMM\");\r\n\r\n  let timeSinceLastTest =\r\n    (new Date().getTime() - parsed[0].Date.getTime()) / 1000;\r\n\r\n  let dateOfLastTestMessage =\r\n    dateOfLastTest + \" (\" + (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.createTimeMessage)(timeSinceLastTest) + \" ago)\";\r\n\r\n  document.getElementById(\"timeSinceLastSong\").innerHTML =\r\n    dateOfLastTestMessage;\r\n\r\n  let byDay = getByDay(parsed);\r\n  let lastTwoWeeks = getLastTwoWeeks(parsed);\r\n  let byWeek = getAllWeeks(parsed);\r\n\r\n  const dataToSave = { byDay, byWeek, lastTwoWeeks };\r\n\r\n  return dataToSave;\r\n}\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/spotifyChart.js?");

/***/ }),

/***/ "./src/typingSpeed.js":
/*!****************************!*\
  !*** ./src/typingSpeed.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usefullFunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usefullFunc */ \"./src/usefullFunc.js\");\n\r\n\r\nlet typingToggleState = 0;\r\nlet typingData = {};\r\nlet typingChart;\r\n\r\nfunction switchTypingDots() {\r\n  let circles = Array.from(document.getElementsByClassName(\"typingCircles\"));\r\n  let desc = document.getElementById(\"typingDesc\");\r\n\r\n  switch (typingToggleState) {\r\n    case 0:\r\n      desc.innerHTML = \"How has my typing speed improved over time?\";\r\n      break;\r\n    case 1:\r\n      desc.innerHTML =\r\n        \"This graph shows my average WPM at each hour of the day.\";\r\n      break;\r\n  }\r\n  circles.forEach((c) =>\r\n    c.id.slice(-1) == typingToggleState\r\n      ? (c.style.fill = \"black\")\r\n      : (c.style.fill = \"none\")\r\n  );\r\n}\r\n\r\nfunction typingToggle() {\r\n  switchTypingDots();\r\n  switch (typingToggleState) {\r\n    case 0:\r\n      updateTypingNormal();\r\n      break;\r\n\r\n    case 1:\r\n      updateTypingPerHour();\r\n      break;\r\n  }\r\n  typingToggleState == 1 ? (typingToggleState = 0) : typingToggleState++;\r\n}\r\n\r\nfunction fetchTyping() {\r\n  const primaryUrl = \"https://api.artomweb.com/cache/typing\";\r\n  const fallbackUrl =\r\n    \"https://docs.google.com/spreadsheets/d/e/2PACX-1vTiOrp7SrLbvsgrusWvwFcllmSUov-GlAME8wvi7p3BTVCurKFh_KLlCVQ0A7luijiLa6F9fOKqxKAP/pub?output=csv\";\r\n\r\n  function parseCSV(url) {\r\n    Papa.parse(url, {\r\n      download: true,\r\n      header: true,\r\n      complete: function (results) {\r\n        try {\r\n          processTyping(results.data, url);\r\n        } catch (error) {\r\n          console.log(\"Error processing data:\", error);\r\n          if (url !== fallbackUrl) {\r\n            console.log(\"Trying the fallback URL...\");\r\n            parseCSV(fallbackUrl);\r\n          } else {\r\n            let typingCard = document.getElementById(\"typingCard\");\r\n            typingCard.style.display = \"none\";\r\n          }\r\n        }\r\n      },\r\n      error: function (error) {\r\n        console.log(\"Failed to fetch typing data from:\", url);\r\n        if (url === primaryUrl) {\r\n          console.log(\"Trying the fallback URL...\");\r\n          parseCSV(fallbackUrl);\r\n        } else {\r\n          let typingCard = document.getElementById(\"typingCard\");\r\n          typingCard.style.display = \"none\";\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  // Try to fetch data from the primary URL first\r\n  parseCSV(primaryUrl);\r\n}\r\n\r\nfetchTyping();\r\n\r\nfunction showSymbols() {\r\n  let symbols = document.getElementsByClassName(\"symbol\");\r\n\r\n  for (let s of symbols) {\r\n    s.style.display = \"inline\";\r\n  }\r\n}\r\n\r\nfunction updateTypingPerHour() {\r\n  const { timOfDayLabels, timOfDayData, pointRadiusArray } = typingData;\r\n\r\n  typingChart.options.scales.x = {\r\n    type: \"linear\",\r\n    position: \"bottom\",\r\n    ticks: {\r\n      stepSize: 1,\r\n      callback: function (value, index, values) {\r\n        return `${value}:00`;\r\n      },\r\n    },\r\n  };\r\n\r\n  typingChart.options.plugins.tooltip.callbacks.title = function (tooltipItem) {\r\n    return tooltipItem[0].label + \":00\";\r\n  };\r\n\r\n  typingChart.data.labels = timOfDayLabels;\r\n  typingChart.data.datasets = [\r\n    {\r\n      data: timOfDayData,\r\n      backgroundColor: \"#f4a4a4\",\r\n      tension: 0.1,\r\n      fill: true,\r\n      pointRadius: pointRadiusArray,\r\n    },\r\n  ];\r\n\r\n  typingChart.update();\r\n}\r\n\r\nfunction updateTypingNormal() {\r\n  const { labels, data } = typingData;\r\n\r\n  typingChart.options.plugins.tooltip.callbacks.title = function (tooltipItem) {\r\n    return tooltipItem[0].label;\r\n  };\r\n\r\n  typingChart.options.scales.x = {\r\n    maxTicksLimit: 6.3,\r\n    ticks: {\r\n      stepSize: 5,\r\n      maxRotation: 0,\r\n      minRotation: 0,\r\n    },\r\n  };\r\n  typingChart.data.labels = labels;\r\n  typingChart.data.datasets = [\r\n    {\r\n      data: data,\r\n      backgroundColor: \"#f4a4a4\",\r\n      tension: 0.1,\r\n      fill: true,\r\n    },\r\n  ];\r\n\r\n  typingChart.update();\r\n}\r\n\r\nfunction processTyping(dataIn) {\r\n  showSymbols();\r\n  updateTypingData(dataIn);\r\n\r\n  drawtypingChart();\r\n  typingToggle();\r\n}\r\n\r\nfunction updateTypingData(dataIn) {\r\n  // dataIn = dataIn.slice(-2000);\r\n  dataIn.forEach((elt) => {\r\n    elt.timestamp = new Date(+elt.timestamp);\r\n    elt.wpm = +elt.wpm;\r\n  });\r\n\r\n  dataIn = _.sortBy(dataIn, (point) => point.timestamp.getTime());\r\n\r\n  const hoursOfDay = Array.from({ length: 24 }, (_, i) =>\r\n    i.toString().padStart(2, \"0\")\r\n  );\r\n\r\n  const byTimeOfDay = _.chain(dataIn)\r\n    .groupBy((d) => {\r\n      return moment(d.timestamp).format(\"HH\");\r\n    })\r\n    .map((entries, hour) => {\r\n      return {\r\n        hour: +hour,\r\n        avg: Math.round(_.meanBy(entries, (entry) => +entry.wpm) * 10) / 10,\r\n        // avg: Math.round(_.maxBy(entries, \"wpm\").wpm * 10) / 10,\r\n      };\r\n    })\r\n    .sortBy((d) => d.hour)\r\n    .value();\r\n\r\n  console.log(byTimeOfDay);\r\n\r\n  const completedByTimeOfDay = _.map(hoursOfDay, (hour) => {\r\n    const existingHourData = byTimeOfDay.find(\r\n      (item) => item.hour === parseInt(hour)\r\n    );\r\n    return existingHourData || { hour: +hour, avg: 0 };\r\n  });\r\n\r\n  const timOfDayLabels = completedByTimeOfDay.map((item) => item.hour);\r\n  const timOfDayData = completedByTimeOfDay.map((item) => item.avg);\r\n\r\n  const pointRadiusArray = completedByTimeOfDay.map((item) =>\r\n    item.avg !== 0 ? 3 : 0\r\n  );\r\n\r\n  let weekAvg = _.chain(dataIn)\r\n    .groupBy((d) => {\r\n      return moment(d.timestamp).format(\"MMM YY\");\r\n    })\r\n    .map((entries, week) => {\r\n      // console.log(entries);\r\n      return {\r\n        wofy: week,\r\n        avg: Math.round(_.meanBy(entries, (entry) => +entry.wpm) * 10) / 10,\r\n      };\r\n    })\r\n    .value();\r\n\r\n  weekAvg.sort(\r\n    (a, b) => moment(a.wofy, \"MMM YYYY\") - moment(b.wofy, \"MMM YYYY\")\r\n  );\r\n  // console.log(weekAvg);\r\n\r\n  // console.log(weekAvg);\r\n\r\n  const labels = weekAvg.map((el) => el.wofy);\r\n  const data = weekAvg.map((el) => el.avg);\r\n\r\n  let sortedWPM = _.sortBy(dataIn, (point) => point.timestamp.getTime());\r\n\r\n  const maxWPM = +_.maxBy(dataIn, \"wpm\").wpm;\r\n\r\n  // Only last 500 tests\r\n\r\n  let dataRecent = sortedWPM.slice(-500);\r\n\r\n  // speed change per hour\r\n\r\n  let wpmPoints = dataRecent.map((point) => +point.wpm);\r\n\r\n  const trend = (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.findLineByLeastSquares)(wpmPoints);\r\n\r\n  const wpmChange = trend[1][1] - trend[0][1];\r\n\r\n  const delta = dataRecent.length * 30;\r\n\r\n  const changeInWPMPerMinSigned = (wpmChange * (3600 / delta)).toFixed(2);\r\n\r\n  const PorNchange = changeInWPMPerMinSigned > 0 ? \"+\" : \"-\";\r\n\r\n  const changeInWPMPerMin = Math.abs(changeInWPMPerMinSigned);\r\n\r\n  // console.log(changeInWPMPerMin, PorNchange);\r\n\r\n  // avg wpm and acc\r\n\r\n  const avgWPM = _.meanBy(dataRecent, (o) => +o.wpm).toFixed(2);\r\n  const avgACC = Math.round(\r\n    _.meanBy(dataRecent, (o) => +o.acc),\r\n    0\r\n  );\r\n\r\n  //time since last test\r\n\r\n  const dateOfLastTest = moment(\r\n    dataRecent[dataRecent.length - 1].timestamp\r\n  ).format(\"Do [of] MMMM\");\r\n\r\n  const timeSinceLastTest =\r\n    (new Date().getTime() -\r\n      dataRecent[dataRecent.length - 1].timestamp.getTime()) /\r\n    1000;\r\n\r\n  const dateOfLastTestMessage =\r\n    dateOfLastTest + \" (\" + (0,_usefullFunc__WEBPACK_IMPORTED_MODULE_0__.createTimeMessage)(timeSinceLastTest) + \" ago)\";\r\n\r\n  // number of tests per day\r\n\r\n  const firstTest = dataRecent[0];\r\n  const lastTest = dataRecent[dataRecent.length - 1];\r\n\r\n  const dayDiff =\r\n    (lastTest.timestamp - firstTest.timestamp) / (1000 * 60 * 60 * 24);\r\n\r\n  const testsPerDay = (dataRecent.length / dayDiff).toFixed(1);\r\n\r\n  const totalTimeMessage =\r\n    Math.round((dataIn.length * 30) / (60 * 60)) + \" hours\";\r\n\r\n  typingData = {\r\n    labels,\r\n    data,\r\n    timOfDayLabels,\r\n    timOfDayData,\r\n    pointRadiusArray,\r\n  };\r\n\r\n  document.getElementById(\"timeSinceLastTest\").innerHTML =\r\n    dateOfLastTestMessage;\r\n  document.getElementById(\"highestTypingSpeed\").innerHTML = maxWPM;\r\n  document.getElementById(\"averageTypingSpeed\").innerHTML = avgWPM;\r\n  document.getElementById(\"averageAccuracy\").innerHTML = avgACC;\r\n  document.getElementById(\"totalTime\").innerHTML = totalTimeMessage;\r\n  document.getElementById(\"testsPerDay\").innerHTML = testsPerDay;\r\n  document.getElementById(\"wpmChangePerHour\").innerHTML =\r\n    PorNchange + changeInWPMPerMin;\r\n}\r\n\r\nfunction drawtypingChart() {\r\n  let ctx = document.getElementById(\"monkeyChart\").getContext(\"2d\");\r\n\r\n  typingChart = new Chart(ctx, {\r\n    type: \"line\",\r\n    data: {},\r\n\r\n    options: {\r\n      maintainAspectRatio: true,\r\n      responsive: true,\r\n\r\n      plugins: {\r\n        legend: {\r\n          display: false,\r\n        },\r\n        tooltip: {\r\n          callbacks: {\r\n            label: function (context) {\r\n              let label = context.dataset.label || \"\";\r\n\r\n              if (label) {\r\n                label += \": \";\r\n              }\r\n              if (context.parsed.y !== null) {\r\n                label += context.parsed.y + \" WPM\";\r\n              }\r\n              return label;\r\n            },\r\n          },\r\n        },\r\n      },\r\n      scales: {\r\n        y: {\r\n          title: {\r\n            text: \"Average WPM\",\r\n            display: true,\r\n          },\r\n          beginAtZero: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/typingSpeed.js?");

/***/ }),

/***/ "./src/usefullFunc.js":
/*!****************************!*\
  !*** ./src/usefullFunc.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTimeMessage: () => (/* binding */ createTimeMessage),\n/* harmony export */   findLineByLeastSquares: () => (/* binding */ findLineByLeastSquares),\n/* harmony export */   shuffle: () => (/* binding */ shuffle)\n/* harmony export */ });\nfunction createTimeMessage(seconds) {\r\n  let duration = moment.duration(seconds, \"seconds\");\r\n  return duration.humanize();\r\n}\r\n\r\n// https://github.com/monkeytypegame/monkeytype\r\nfunction findLineByLeastSquares(values_y) {\r\n  let sum_x = 0;\r\n  let sum_y = 0;\r\n  let sum_xy = 0;\r\n  let sum_xx = 0;\r\n  let count = 0;\r\n\r\n  let x = 0;\r\n  let y = 0;\r\n  let values_length = values_y.length;\r\n\r\n  if (values_length === 0) {\r\n    return [[], []];\r\n  }\r\n\r\n  for (let v = 0; v < values_length; v++) {\r\n    x = v + 1;\r\n    y = values_y[v];\r\n    sum_x += x;\r\n    sum_y += y;\r\n    sum_xx += x * x;\r\n    sum_xy += x * y;\r\n    count++;\r\n  }\r\n\r\n  let m = (count * sum_xy - sum_x * sum_y) / (count * sum_xx - sum_x * sum_x);\r\n  let b = sum_y / count - (m * sum_x) / count;\r\n\r\n  let returnpoint1 = [1, 1 * m + b];\r\n  let returnpoint2 = [values_length, values_length * m + b];\r\n  return [returnpoint1, returnpoint2];\r\n}\r\n\r\nfunction shuffle(array) {\r\n  let currentIndex = array.length,\r\n    randomIndex;\r\n\r\n  // While there remain elements to shuffle.\r\n  while (currentIndex != 0) {\r\n    // Pick a remaining element.\r\n    randomIndex = Math.floor(Math.random() * currentIndex);\r\n    currentIndex--;\r\n\r\n    // And swap it with the current element.\r\n    [array[currentIndex], array[randomIndex]] = [\r\n      array[randomIndex],\r\n      array[currentIndex],\r\n    ];\r\n  }\r\n\r\n  return array;\r\n}\r\n\n\n//# sourceURL=webpack://artomweb.github.io/./src/usefullFunc.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;